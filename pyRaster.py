""" Subclass of MainFrame generated by wxFormBuilder and then heavily modified.
    KJR April 2011
    Hu Group, SEAS Harvard
"""

import wx
from wx.lib.pubsub import Publisher
import Raster_GUI
import matplotlib
if matplotlib.get_backend() != 'WXAgg':
    """ This conditional is just to check if it's loaded so that python doesn't
        complain. If it already was loaded and set to a different backend, 
        we couldn't change it anyway (which is why python issues a warning if
        we use the 'use' method and a backend has already been loaded).
    """
    matplotlib.use('WXAgg')

import pylab
import numpy
import cPickle
import gzip
import kasey_utils as kc
import h5py
import os.path
import time

# Define notification event for thread completion
EVT_RESULT_ID = wx.NewId()
EVT_UPDATE_ID = wx.NewId()

def EVT_RESULT(win, func):
    """Define Result Event."""
    win.Connect(-1, -1, EVT_RESULT_ID, func)

def EVT_UPDATE(win, func):
    """Define Update Event."""
    win.Connect(-1, -1, EVT_UPDATE_ID, func)


class MainApp( wx.App ): 
    def __init__( self, redirect=False, filename=None ):
        wx.App.__init__( self, redirect, filename )
        self.Bind( wx.EVT_CLOSE, self.on_close_Raster )
        
        self.mainframe = Raster( None )
    
    def on_close_Raster( self, event ):
        self.Destroy()


class Raster( Raster_GUI.MainFrame ):
    def __init__( self, parent ):
        Raster_GUI.MainFrame.__init__( self, parent=None )

        self.fig1.canvas.mpl_connect( 'button_press_event', self.on_click_canvas1 )
        self.fig1.canvas.mpl_connect( 'motion_notify_event', self.on_move_in_axes1 )
        self.fig1.canvas.mpl_connect( 'axes_leave_event', self.on_leave_axes1 )

        self.fig2.canvas.mpl_connect( 'motion_notify_event', self.on_move_in_axes2 )
        self.fig2.canvas.mpl_connect( 'resize_event', self.on_resize )
        self.fig2.canvas.mpl_connect( 'draw_event', self.on_draw_canvas2 )
        self.fig2.canvas.mpl_connect( 'axes_leave_event', self.on_leave_axes2 )

        if hasattr( parent, 'positioners' ):
            self.positioners = True
            self.piezoX = parent.positioners['piezoX']
            self.piezoY = parent.positioners['piezoY']
            self.piezoZ = parent.positioners['piezoZ']
            self.X = self.piezoX['control'].PositionCh1
            self.Y = self.piezoY['control'].PositionCh1
            self.Z = self.piezoZ['control'].PositionCh1
            
            # assume ranges are the same for all piezos
            self.PiezoMin = self.piezoX['control'].min_position * 1000 # (nm) 
            self.PiezoMax = self.piezoX['control'].max_position * 1000 # (nm) 

            # Set up event handler for any worker thread results
            EVT_RESULT( self, self.on_thread_terminate )
            EVT_UPDATE( self, self.on_thread_update )
        else:
            self.positioners = None
            self.statusbar.SetStatusText( 'No positioners detected; analysis mode only', 2 )
            # need these for plotting. ideally this info would be stored with the data...
            self.piezoX = dict( direction=-1 )
            self.piezoY = dict( direction=1 )

        self.rowlabel_column = -1 # set by wxpython; named here for clarity
        self.grid_color_column = 0
        self.grid_x_column = 1
        self.grid_y_column = 2
        self.grid.SetColLabelValue( self.grid_color_column, '' )
        self.grid.SetColSize( self.grid_color_column, 30 )
        self.grid.SetColLabelValue( self.grid_x_column, 'X (um)' )
        self.grid.SetColSize( self.grid_x_column, 100 )
        self.grid.SetColLabelValue( self.grid_y_column, 'Y (um)' )
        self.grid.SetColSize( self.grid_y_column, 100 )
        self.grid.SetDefaultCellOverflow( False )
        
        self.line_list=[]
        # these colors are rgb tuples, with 255 as max
        self.color_list = [ (0, 0, 255),
                            (0, 125, 0),
                            (255, 0, 0),
                            (0, 190, 190),
                            (190, 0, 190),
                            (190, 190, 0),
                            (0, 0, 0) ]
        self.color_data = wx.ColourData()

        self.worker = None
        self.data = None
        self.DataPath = ""
        self.num_acquisitions = 0
        self.to_be_saved = False
        self.button_save.SetLabel('N/A')

        self.scan_width = float( self.txtctrl_scan_width.GetValue() )
        self.scan_num_xpoints = int( self.txtctrl_scan_num_xpoints.GetValue() )
        self.scan_height = float( self.txtctrl_scan_height.GetValue() )
        self.scan_num_ypoints = int( self.txtctrl_scan_num_ypoints.GetValue() )
        self.scan_zrange = float( self.txtctrl_scan_zrange.GetValue() )
        self.scan_num_zpoints = int( self.txtctrl_scan_num_zpoints.GetValue() )
        self.move_to_click = False
        self.mouse_on_colormap = False
        
        self.GUI_3D_controls = [ self.staticline_z,
                                 self.txtlabel_zrange,
                                 self.txtctrl_scan_zrange,
                                 self.txtlabel_zpoints,
                                 self.txtctrl_scan_num_zpoints,
                                 self.txtlabel_zres,
                                 self.txtlabel_scan_z_resolution ]
        
        self.hide_3D_controls()
        self.Show( True )


    def clear_fig2( self, event ):
        self.moveline = None
        self.fig2.axes.cla()
        self.fig2.canvas.draw()
        self.grid.DeleteRows( pos=0, numRows=self.grid.GetNumberRows() )
        self.plot_data() # replot axes1 without markers


    def display_position( self, x, y, lum=None ):
        """ Update statusbar field 1 (zero-indexed, of course) with the current
            mouse position
        """
        text = "x:"+str(x)+", y:"+str(y)
        if lum is not None:
            text += ", lum:"+str(lum)
        self.statusbar.SetStatusText( text, 1 )


    def get_color( self, row ):
        """
        This is mostly from the wxPython Demo!
        """
        self.color_data.SetColour( wx.Colour( *self.line_list[row]['color'] ))
            
        dlg = wx.ColourDialog( self, self.color_data )
 
        # Ensure the full colour dialog is displayed, 
        # not the abbreviated version.
        dlg.GetColourData().SetChooseFull(True)
        
        if dlg.ShowModal() == wx.ID_OK:
            data = dlg.GetColourData()
            color = data.GetColour().Get()
            #print 'You selected: %s\n' % str(color)
        else:
            color=None
            
        dlg.Destroy()
        return color



    def hide_3D_controls( self ):
        for item in self.GUI_3D_controls: item.Hide()
        self.mainpanel.Layout()
        

    def show_3D_controls( self ):
        for item in self.GUI_3D_controls: item.Show()
        self.mainpanel.Layout()


    def make_cmap_matrix( self ):
        if self.data is None: return True
        self.cmap_matrix = pylab.zeros([ len(self.data['ypoints']),
                                    len(self.data['xpoints']) ])
        
        

    def move_to_position( self, position ):
        self.piezoX['control'].SetPositionSmooth( position=position['x'], step=0.25 )
        self.piezoY['control'].SetPositionSmooth( position=position['y'], step=0.25 )
        
        Publisher().sendMessage("piezos-moved", 'raster')


    def on_button_move_to_click_clicked( self, event ):
        if self.move_to_click == False:
            self.move_to_click = True
            self.button_move_to_click.SetLabel("Cancel")
        else:
            self.move_to_click = False
            self.button_move_to_click.SetLabel("Move to click")


    def on_button_save_clicked( self, event ):
        if event!="start_3D" and self.data is None: return True
        
        dlg = wx.FileDialog( self, ("Save data to a *.hdf5 file " +
                                "(extension will be automatically appended)"),
                    style=wx.SAVE|wx.FD_OVERWRITE_PROMPT )
        dlg.SetWildcard("Hu Group raster file (*.hdf5)|*.hdf5")

        if dlg.ShowModal() == wx.ID_OK:
            self.DataPath = dlg.GetPath()
            self.DataPath = os.path.splitext(self.DataPath)[0] # we'll append extension later
            #if os.path.splitext(self.DataPath)[1] != '.hdf5':
            #    self.DataPath = os.path.splitext(self.DataPath)[0] + '.hdf5'
                
            if self.worker is None:
                self.statusbar.SetStatusText("Saving data...")
                self.save_data()
                self.button_save.SetLabel('Saved')
            else:
                self.to_be_saved = True
                self.button_save.SetLabel('To be saved')
        dlg.Destroy()
        self.statusbar.SetStatusText("")


    def on_button_save_mouseleave( self, event ):
        pass
        #self.statusbar.SetStatusText("")
    

    def on_button_save_mouseover( self, event ):
        pass
        #self.statusbar.SetStatusText("Save data to a *.hdf5 file after scan has finished.")
    

    def on_button_start_clicked( self, event ):
        # Trigger the worker thread unless it's already busy
        if self.positioners is not None:
            self.use_winspec = self.choice_Winspec_or_APDs.GetSelection() == 0
            if not self.within_piezo_limits():
                self.statusbar.SetStatusText( 'SCAN EXCEEDS PIEZO RANGE!!! Aborted.', 0 )
                return False                
            
            if not self.worker:
                self.statusbar.SetStatusText( 'Starting scan.', 0 )
                self.worker = WorkerThread( self )
                self.worker.setDaemon( True ) # kill this thread if we close the main app

                self.button_save.SetLabel('Save at end')
                self.button_move_to_click.SetLabel("-----")
                self.to_be_saved = False
                self.num_acquisitions = 0
                if self.menu_scan_3D.IsChecked():
                    self.on_button_save_clicked(event="start_3D")

                self.worker.start()


    def on_button_stop_clicked( self, event ):
        # Flag the worker thread to stop if running
        if self.worker:
            self.statusbar.SetStatusText('Trying to abort scan.', 0)
            self.worker.abort()
            self.button_save.SetLabel('Save partial')


    def on_click_canvas1( self, event ):
        if not event.inaxes: return True
        if self.data is None: return True
        if not self.use_winspec: return True

        self.wavelen = self.data['wavelen']
        
        x = event.xdata
        y = event.ydata
        if self.move_to_click == True:
            self.move_to_position( dict(x=x, y=y) )
            self.move_to_click = False
            self.button_move_to_click.SetLabel("Move to click")
            return True
        
        if self.piezoY['direction'] == 1:
            iy = pylab.find( y<self.ycorners )[-1]
        else:
            iy = pylab.find( y>self.ycorners )[-1]

        if self.piezoX['direction'] == 1:
            ix = pylab.find( x<self.xcorners )[-1]
        else:
            ix = pylab.find( x>self.xcorners )[-1]
        
        #if self.data['scans'][ix][iy]['lum'] == 0:
        if self.cmap_matrix[ix,iy] == 0:
            # empty pixel
            return True
        
        self.grid.AppendRows(1)
        new_row = self.grid.GetNumberRows()-1
        self.grid.SetCellValue( new_row, self.grid_x_column, "%.3f"%(x) )
        self.grid.SetReadOnly( new_row, self.grid_x_column )
        self.grid.SetCellValue( new_row, self.grid_y_column, "%.3f"%(y) )
        self.grid.SetReadOnly( new_row, self.grid_y_column )
        color=self.color_list[ pylab.mod(new_row, len(self.color_list)) ]
        self.grid.SetCellBackgroundColour( new_row, self.grid_color_column, color )
        self.grid.FitInside()
        self.mainpanel.Layout()
        self.Refresh()
        self.line_list.append(
            dict(spectrum=self.data['scans'][ix][iy]['lum'],
                 x=x,
                 y=y,
                 color=color))
        self.update_fig1_markers()
        self.update_fig2( ix, iy )
        

    def update_fig2(self, ix=None, iy=None):
        for line in self.line_list:
            self.fig2.axes.plot( self.wavelen, line['spectrum'], color=[c/255.0 for c in line['color']] )

        self.fig2.axes.set_xlim( [self.wavelen[0], self.wavelen[-1]] )
        self.fig2.canvas.draw()

        if ix is not None:
            new_row = self.grid.GetNumberRows()-1
            nextcolor = self.color_list[ pylab.mod(new_row+1, len(self.color_list)) ]
            self.moveline, = self.fig2.axes.plot( self.wavelen, self.data['scans'][ix][iy]['lum'],
                                color=[c/255.0 for c in nextcolor], animated=True )

        self.line_min, = self.fig2.axes.plot( [self.wavelen[int(self.slider_integration_min.GetValue())]]*2,
                            self.fig2.axes.get_ylim(), 'k--' )
        self.line_max, = self.fig2.axes.plot( [self.wavelen[int(self.slider_integration_max.GetValue())]]*2,
                            self.fig2.axes.get_ylim(), 'k--' )


        self.fig2.axes.set_xlim( [self.wavelen[0], self.wavelen[-1]] )
        self.fig2bg = self.fig2.canvas.copy_from_bbox( self.fig2.axes.bbox )

        return True


    def on_close_MainFrame( self, event ):
        self.Destroy()
        event.Skip()


    def on_draw_canvas2( self, event ):
        """ I'm trying to adjust our bitmap of canvas2 so that if we zoom
            or pan it the bitmap will get updated and not snap back to pre-
            zoomed or panned
        """
        self.fig2bg = self.fig2.canvas.copy_from_bbox( self.fig2.axes.bbox )
        return True


    def on_grid_label_right_click( self, event ):
        if event.GetCol() == self.rowlabel_column:
            if not hasattr(self, "popupID2"):
                self.popupID2 = wx.NewId()
     
            self.current_row = event.GetRow()
            menu = wx.Menu()
            menu.AppendItem( wx.MenuItem( menu, self.popupID2, "Clear plot" ) )
            wx.EVT_MENU( self, self.popupID2, self.clear_fig2 )
            
            self.PopupMenu(menu)
            menu.Destroy()

    def on_grid_leftclick( self, event ):
        row = event.GetRow()
        col = event.GetCol()
        
        if col == self.grid_color_column:
            color = self.get_color( row )
            if color is not None:
                self.set_line_color( row, color )
                self.update_fig1_markers()


    def on_leave_axes1( self, event ):
        """ reblit fig2 to clear the 'on_move' line
        """
        self.mouse_on_colormap = False
        if not hasattr( self, 'moveline' ): return True
        if self.moveline is None: return True
        
        self.fig2.canvas.restore_region( self.fig2bg )
        self.redraw_fig2()
        self.statusbar.SetStatusText( "", 1 )
        return True


    def on_leave_axes2( self, event ):
        self.statusbar.SetStatusText( "", 1 )
        return True


    def on_menu_file_open( self, event ):
        """ we can only open gzip'd pickles with extension *.HuG or hdf5 files
        """
        if self.worker is not None:
            self.statusbar.SetStatusText('Must stop scan before loading data.')
            return True
        
        self.statusbar.SetStatusText('Open raster file')
        filters = 'HDF5 files|*.hdf5|Hu Group raster files (*.HuG)|*.HuG'
        dialog = wx.FileDialog( parent=self, message='Open raster file',
                    wildcard=filters, style=wx.OPEN )
        
        if dialog.ShowModal() == wx.ID_OK:
            self.statusbar.SetStatusText("Loading data...")
            fname = dialog.GetPath()
            if fname.endswith('.HuG'):
                fobj = gzip.open( fname, 'rb' )
                self.data = cPickle.load( fobj )
                self.data['wavelen'] = pylab.arange(1340)
                self.statusbar.SetStatusText("")
                fobj.close()
                dialog.Destroy()
                self.make_cmap_matrix()
                self.plot_data()
                self.button_save.SetLabel("Save as")
                return True
            elif fname.endswith('.hdf5'):
                with h5py.File( fname, 'r' ) as h5:
                    if 'raster_file' not in h5.keys():
                        self.statusbar.SetStatusText("Not a raster file!")
                        dialog.Destroy()
                        return True
                        
                    if 'wavelength' in h5.keys():
                        wavelen = pylab.array(h5['wavelength'])
                    else:
                        wavelen = pylab.arange(1340)
                        
                    if not 'apd_counts' in h5.keys():
                        self.use_winspec = True
                        spectra = pylab.array(h5['spectra'])
                    else:
                        self.use_winspec = False
                        apd_counts = pylab.array(h5['apd_counts'])
                        
                    xpoints = pylab.array(h5['xpoints'])
                    ypoints = pylab.array(h5['ypoints'])
                    pixels = pylab.array(h5['pixels'])
                    positions = pylab.array(h5['positions'])
                    
                self.data = dict()
                self.data['xpoints'] = xpoints
                self.data['ypoints'] = ypoints
                self.data['wavelen'] = wavelen
                self.data['scans'] = []
                for i in range(len(xpoints)):
                    self.data['scans'].append( [None]*len(ypoints) )
                    
                for i,p in enumerate(pixels):
                    self.data['scans'][p[0]][p[1]] = dict(
                        ix=p[0],
                        iy=p[1],
                        x=positions[i][0],
                        y=positions[i][1]
                        )
                    if self.use_winspec:
                        self.data['scans'][p[0]][p[1]]['lum']=spectra[i]
                    else:
                        self.data['scans'][p[0]][p[1]]['cps']=apd_counts[i]
                        
                self.statusbar.SetStatusText("")
                self.txtctrl_scan_width.SetValue( str(xpoints.max() - xpoints.min()) )
                self.txtctrl_scan_num_xpoints.SetValue( str(len(xpoints)) )
                self.txtctrl_scan_height.SetValue(str(ypoints.max() - ypoints.min()))
                self.txtctrl_scan_num_ypoints.SetValue( str(len(ypoints)) )
                dialog.Destroy()
                self.make_cmap_matrix()
                self.plot_data()
                self.button_save.SetLabel("Save as")
                return True
            else:
                self.statusbar.SetStatusText("Not a Hu Group raster file!")
                dialog.Destroy()
                return True
            
        else:
            self.statusbar.SetStatusText("")
            dialog.Destroy()
            return True


    def on_menu_scan_3D( self, event ):
        if self.menu_scan_3D.IsChecked():
            self.show_3D_controls()
        else:
            self.hide_3D_controls()
            

    def on_move_in_axes1( self, event ):
        self.mouse_on_colormap = True
        if not event.inaxes: return True
        x = event.xdata
        y = event.ydata
        self.display_position( x, y )
        if self.data is None: return True
        if not self.use_winspec: return True
        if not hasattr( self, 'moveline' ): return True
        if self.moveline is None: return True
        
        
        if self.piezoY['direction'] == 1:
            iy = pylab.find( y<self.ycorners )[-1]
        else:
            iy = pylab.find( y>self.ycorners )[-1]

        if self.piezoX['direction'] == 1:
            ix = pylab.find( x<self.xcorners )[-1]
        else:
            ix = pylab.find( x>self.xcorners )[-1]
    
        self.update_moveline_spectrum( ix, iy )
        
        # these don't work for me in this form, but sounded interesting if
        # we experience hang problems when capturing mouse events
        # http://www.mail-archive.com/matplotlib-users@lists.sourceforge.net/msg16793.html
        #event.guiEvent.Skip()
        #if self.HasCapture(): self.ReleaseMouse()
        return True


    def on_move_in_axes2( self, event ):
        if not event.inaxes: return True
        x = event.xdata
        y = event.ydata
        self.display_position( x, y )
        return True


    def on_resize( self, event ):
        """ need to redraw fig2 to update the size of the bitmap 'background'
        """
        self.fig2.canvas.draw()
        self.fig2bg = self.fig2.canvas.copy_from_bbox( self.fig2.axes.bbox )
        return True


    def on_slider_integration_min_moving( self, event ):
        if self.data is None: return True
        if not hasattr(self,'line_min'): return True
        if self.line_min is None: return True

        self.fig2.canvas.restore_region( self.fig2bg )
        self.line_min.set_xdata( [self.wavelen[float(self.slider_integration_min.GetValue())]]*2 )
        self.fig2.axes.draw_artist( self.line_min )
        if self.slider_integration_max.GetValue()<self.slider_integration_min.GetValue():
            self.slider_integration_max.SetValue( self.slider_integration_min.GetValue() )
            self.on_slider_integration_max_changed( None )
        else:            
            self.fig2.axes.draw_artist( self.line_max )
            self.fig2.canvas.blit( self.fig2.axes.bbox )


    def on_slider_integration_min_changed( self, event ):
        if self.data is None: return True
        if not hasattr(self,'line_min'): return True
        if self.line_min is None: return True

        for line in self.data['scans']:
            for scan in line:
                if scan is not None:
                    signal = scan['lum'][self.slider_integration_min.GetValue():self.slider_integration_max.GetValue()]
                    self.cmap_matrix[scan['iy'],scan['ix']] = pylab.sum( signal )
        self.plot_data()
	

    def on_slider_integration_max_moving( self, event ):
        if self.data is None: return True
        if not hasattr(self,'line_max'): return True
        if self.line_max is None: return True

        self.fig2.canvas.restore_region( self.fig2bg )
        self.line_max.set_xdata( [self.wavelen[float(self.slider_integration_max.GetValue())]]*2 )
        self.fig2.axes.draw_artist( self.line_max )

        if self.slider_integration_max.GetValue()<self.slider_integration_min.GetValue():
            self.slider_integration_min.SetValue( self.slider_integration_max.GetValue() )
            self.on_slider_integration_min_changed( None )
        else:            
            self.fig2.axes.draw_artist( self.line_min )
            self.fig2.canvas.blit( self.fig2.axes.bbox )


    def on_slider_integration_max_changed( self, event ):
        if self.data is None: return True
        if not hasattr(self,'line_max'): return True
        if self.line_max is None: return True

        for line in self.data['scans']:
            for scan in line:
                if scan is not None:
                    signal = scan['lum'][self.slider_integration_min.GetValue():self.slider_integration_max.GetValue()]
                    self.cmap_matrix[scan['iy'],scan['ix']] = pylab.sum( signal )
        self.plot_data()
        

    def on_thread_terminate(self, event):
        """Show Result status."""
        if event.data is None:
            self.statusbar.SetStatusText('Scan aborted.',0)
            self.statusbar.SetStatusText('',2)
        elif event.data is True:
            self.statusbar.SetStatusText('Scan is done.',0)
            self.statusbar.SetStatusText('',2)
            if self.to_be_saved is True:
                self.save_data()
            else:
                self.button_save.SetLabel('Save')
                
        self.worker = None
        self.button_move_to_click.SetLabel("Move to click")


    def on_thread_update( self, event ):
        if event.flag != 'Z': self.data = event.data
        self.num_acquisitions += 1
        self.statusbar.SetStatusText( 'Done with acquisition #%s' % (self.num_acquisitions), 2 )
        if (self.num_acquisitions == 1):
            self.make_cmap_matrix()
        if (self.num_acquisitions > 1):
            self.plot_data()
        if self.mouse_on_colormap == False:
            pass
        if event.flag == 'Z':
            # then we are doing a 3D scan and just finished a 2D plane
            self.data['wait_for_save'][0] = True
            self.save_data()
            self.data['wait_for_save'][0] = False
            self.make_cmap_matrix()

    def on_txtctrl_scan_width_changed( self, event ):
        if self.txtctrl_scan_width.GetValue() != "":
            self.scan_width = float( self.txtctrl_scan_width.GetValue() )
            if self.txtctrl_scan_num_xpoints.GetValue() != "" and self.scan_num_xpoints > 1:
                self.txtlabel_scan_width_resolution.SetLabel( "%.3f" % (self.scan_width/(self.scan_num_xpoints-1)) )
    
    def on_txtctrl_scan_num_xpoints_changed( self, event ):
        if self.txtctrl_scan_num_xpoints.GetValue() != "":
            self.scan_num_xpoints = int( self.txtctrl_scan_num_xpoints.GetValue() )
            if self.txtctrl_scan_width.GetValue() != "" and self.scan_num_xpoints > 1:
                self.txtlabel_scan_width_resolution.SetLabel( "%.3f" % (self.scan_width/(self.scan_num_xpoints-1)) )
    
    
    def on_txtctrl_scan_height_changed( self, event ):
        if self.txtctrl_scan_height.GetValue() != "":
            self.scan_height = float( self.txtctrl_scan_height.GetValue() )
            if self.txtctrl_scan_num_ypoints.GetValue() != "" and self.scan_num_ypoints > 1:
                self.txtlabel_scan_height_resolution.SetLabel( "%.3f" % (self.scan_height/(self.scan_num_ypoints-1)) )
    
    
    def on_txtctrl_scan_num_ypoints_changed( self, event ):
        if self.txtctrl_scan_num_ypoints.GetValue() != "":
            self.scan_num_ypoints = int( self.txtctrl_scan_num_ypoints.GetValue() )
            if self.txtctrl_scan_height.GetValue() != "" and self.scan_num_ypoints > 1:
                self.txtlabel_scan_height_resolution.SetLabel( "%.3f" % (self.scan_height/(self.scan_num_ypoints-1)) )
    

    def on_txtctrl_scan_zrange_changed( self, event ):
        if self.txtctrl_scan_zrange.GetValue() != "":
            self.scan_zrange = float( self.txtctrl_scan_zrange.GetValue() )
            if self.txtctrl_scan_num_zpoints.GetValue() != "" and self.scan_num_zpoints > 1:
                self.txtlabel_scan_z_resolution.SetLabel( "%.3f" % (self.scan_zrange/(self.scan_num_zpoints-1)) )
    
    
    def on_txtctrl_scan_num_zpoints_changed( self, event ):
        if self.txtctrl_scan_num_zpoints.GetValue() != "":
            self.scan_num_zpoints = int( self.txtctrl_scan_num_zpoints.GetValue() )
            if self.txtctrl_scan_zrange.GetValue() != "" and self.scan_num_zpoints > 1:
                self.txtlabel_scan_z_resolution.SetLabel( "%.3f" % (self.scan_zrange/(self.scan_num_zpoints-1)) )
    

    def plot_data( self ):
        """ Plots the colormap of raster data in fig1 axes.
        """
        xpoints = pylab.array( self.data['xpoints'] )
        ypoints = pylab.array( self.data['ypoints'] )
        self.xcorners = kc.centers_to_corners( xpoints )
        self.ycorners = kc.centers_to_corners( ypoints )
        
        for line in self.data['scans']:
            for scan in line:
                if scan is not None and self.cmap_matrix[scan['iy'],scan['ix']]==0.0:
                    if self.use_winspec:
                        signal = scan['lum'][self.slider_integration_min.GetValue():self.slider_integration_max.GetValue()]
                        self.cmap_matrix[scan['iy'],scan['ix']] = pylab.sum( signal )
                    else:
                        self.cmap_matrix[scan['iy'],scan['ix']] = scan['cps']
                        
        self.fig1.axes.cla()
        self.cmap = self.fig1.axes.pcolormesh(
                            self.xcorners, self.ycorners, self.cmap_matrix )
        self.fig1.axes.set_xlabel('Position ($\mu m$)')
        self.fig1.axes.set_ylabel('Position ($\mu m$)')
        self.fig1.axes.set_xlim([ self.xcorners.min(), self.xcorners.max() ])
        self.fig1.axes.set_ylim([ self.ycorners.min(), self.ycorners.max() ])

        if self.piezoX['direction'] == 1:
            self.fig1.axes.invert_xaxis()
        
        if self.piezoY['direction'] == 1:
            self.fig1.axes.invert_yaxis()
        
        self.fig1.axes.set_aspect('equal')
        self.fig1.canvas.draw()
        self.update_fig1_markers()

    def update_fig1_markers(self):
        for line in self.line_list:
            self.fig1.axes.plot( line['x'], line['y'], 'o', color=[c/255.0 for c in line['color']],
                                scalex=False, scaley=False )
            self.fig1.canvas.draw()

    def redraw_fig2( self ):
        if hasattr( self, 'line_min' ):
            self.fig2.axes.draw_artist( self.line_min )
        if hasattr( self, 'line_max' ):
            self.fig2.axes.draw_artist( self.line_max )
        self.fig2.canvas.blit( self.fig2.axes.bbox )


    def save_data( self ):
        """ Saves data as a gzip'd hdf5 file containing separate datasets for:
            xpoints (1D)
            ypoints (1D)
            z (single value)
            pixels (2D, ix and iy)
            positions (2D, x and y)
            spectra (2D, vector of spectra)
        """
        pixels = []
        positions = []
        spectra = []
        apd_counts = []
        for rows in self.data['scans'][:]:
            for scan in rows:
                if scan is not None:
                    pixels.append( pylab.array([ scan['ix'], scan['iy'] ], dtype=numpy.int ) )
                    positions.append( pylab.array([ scan['x'], scan['y'] ], dtype=numpy.float ) )
                    if self.use_winspec:
                        spectra.append( scan['lum'] )
                    else:
                        apd_counts.append( scan['cps'] )
                        
        spectra = pylab.array( spectra )
        fname = self.DataPath
        if self.menu_scan_3D.IsChecked(): fname += "z"+str(self.data['z']*1000)
        with h5py.File( fname+".hdf5", 'w' ) as d:
            d.create_dataset( 'raster_file', data=1 )
            d.create_dataset( 'xpoints', data=self.data['xpoints'], compression='gzip' )
            d.create_dataset( 'ypoints', data=self.data['ypoints'], compression='gzip' )
            d.create_dataset( 'z', data=self.data['z'] )
            d.create_dataset( 'pixels', data=pixels, compression='gzip' )
            d.create_dataset( 'positions', data=positions, compression='gzip' )
            if self.use_winspec:
                d.create_dataset( 'wavelength', data=self.data['wavelen'], compression='gzip' )
                d.create_dataset( 'spectra', data=spectra, compression='gzip' )
            else:
                d.create_dataset( 'apd_counts', data=apd_counts, compression='gzip' )

    def set_line_color( self, row, color, update_plot=True ):
        self.line_list[row]['color'] = color
        self.grid.SetCellBackgroundColour( row, self.grid_color_column, color )
        if update_plot:
            self.update_fig2()
            self.Refresh()


    def update_moveline_spectrum( self, ix, iy ):
        self.fig2.canvas.restore_region( self.fig2bg )
        try:
            if self.data['scans'][ix][iy] is not None:
                self.moveline.set_ydata( self.data['scans'][ix][iy]['lum'] )
                self.fig2.axes.draw_artist( self.moveline )
            self.redraw_fig2()
        except IndexError:
            # I think this shouldn't happen in principle, but in practice
            # the colormap may not exactly reach the axes. We'll handle it
            # as if we just did. 
            self.on_leave_axes1( None )


    def within_piezo_limits( self ):
        X = self.piezoX['control'].PositionCh1
        Y = self.piezoY['control'].PositionCh1
        Z = self.piezoZ['control'].PositionCh1
        if X+self.scan_width/2 > self.PiezoMax: return False
        if X-self.scan_width/2 < self.PiezoMin: return False
        if Y+self.scan_height/2 > self.PiezoMax: return False
        if Y-self.scan_height/2 < self.PiezoMin: return False
        if self.menu_scan_3D.IsChecked():
            if Z+self.scan_zrange/2 > self.PiezoMax: return False
            if Z-self.scan_zrange/2 < self.PiezoMin: return False
        return True
        
"""
####################################################################################################################################
"""        
if not __name__ == "__main__":
    ####
    #### Definitions from here down pertain to thread creation and hardware control
    ####

    try:
        from threading import Thread

        import comtypes.client as cc
        cc.GetModule( ('{1A762221-D8BA-11CF-AFC2-508201C10000}',3,11))
        import comtypes.gen.WINX32Lib as WinSpecLib
        expt_running = WinSpecLib.EXP_RUNNING

        import win32com.client as w32c
        from win32com.client import constants

        from ctypes import byref, pointer, c_long, c_float, c_bool
        import ctypes
        phlib = ctypes.windll.phlib
    except ImportError:
        pass

    class ResultEvent(wx.PyEvent):
        def __init__(self, data):
            wx.PyEvent.__init__(self)
            self.SetEventType(EVT_RESULT_ID)
            self.data = data
            
    class UpdateEvent(wx.PyEvent):
        def __init__(self, data, flag=None):
            wx.PyEvent.__init__(self)
            self.SetEventType(EVT_UPDATE_ID)
            self.data = data
            self.flag = flag

    # Thread class that executes processing
    class WorkerThread(Thread):
        """Worker Thread Class. I stole this class (and the Result Event Class above) from wiki.wxpython.org"""
        def __init__( self, parent ):
            Thread.__init__(self)
            self._parent = parent
            self._want_abort = 0
            self.scan_3D = parent.menu_scan_3D.IsChecked()

            self.scan_width = float( parent.txtctrl_scan_width.GetValue() )
            self.scan_num_xpoints = int( parent.txtctrl_scan_num_xpoints.GetValue() )
            self.scan_height = float( parent.txtctrl_scan_height.GetValue() )
            self.scan_num_ypoints = int( parent.txtctrl_scan_num_ypoints.GetValue() )
            self.scan_zrange = float( parent.txtctrl_scan_zrange.GetValue() )
            self.scan_num_zpoints = int( parent.txtctrl_scan_num_zpoints.GetValue() )

            self.scan_start = 0 # top left corner (no others yet implemented)
            
            self.xstep = self.scan_width / (self.scan_num_xpoints - 1)
            self.ystep = self.scan_height / (self.scan_num_ypoints - 1)

            self.piezoX = parent.piezoX
            self.piezoY = parent.piezoY
            self.piezoZ = parent.piezoZ
            
            self.X = self.piezoX['control'].PositionCh1
            self.Y = self.piezoY['control'].PositionCh1
            self.Z = self.piezoZ['control'].PositionCh1
            
            self.use_winspec = parent.choice_Winspec_or_APDs.GetSelection() == 0
            

        def abort( self ):
            """abort worker thread."""
            self._want_abort = 1


        def add_signal_to_matrix( self, position ):
            d = position.copy()
            if self.use_winspec:
                d['lum'] = self.spectrum
            else:
                d['cps'] = self.APD_cps
            self.scans[d['ix']][d['iy']] = d
            self.lastpoint['x'] = d['ix']
            self.lastpoint['y'] = d['iy']
            

        def acquire_signal( self, point, steps_completed ):
            if self.use_winspec:
                self.acquire_spectrum()
                if steps_completed == 0: self.get_wavelength()
            else:
                self.read_APDs()
            self.add_signal_to_matrix( point )


        def acquire_spectrum( self ):
            if self.WinspecExpt.Start( self.WinspecDoc )[0]: # start the experiment
            #if self.WinspecExpt.StartNoGUI(): # start the experiment
                # Wait for acquisition to finish (and check for errors continually)
                # If we didn't care about errors, we could just run WinspecExpt.WaitForExperiment()
                expt_is_running, status = self.WinspecExpt.GetParam( expt_running )
                while expt_is_running and status == 0:
                    expt_is_running, status = self.WinspecExpt.GetParam(expt_running )
                if status != 0:
                    print 'MsgBox ("Error running experiment.")'

                datapointer = c_float()
                self.spectrum = self.WinspecDoc.GetFrame( 1, datapointer )
            else:
                raise ValueError( "Could not initiate acquisition." )


        def calculate_raster_points( self ):
            centerX = self.X
            centerY = self.Y
            centerZ = self.Z
            self.origin = dict( x=centerX, y=centerY, z=centerZ )

            xpoints = pylab.linspace( centerX+self.scan_width/2*self.piezoX['direction'], 
                                      centerX-self.scan_width/2*self.piezoX['direction'], 
                                      self.scan_num_xpoints )
            self.xpoints = list(xpoints)
            ypoints = pylab.linspace( centerY+self.scan_height/2*self.piezoY['direction'], 
                                      centerY-self.scan_height/2*self.piezoY['direction'], 
                                      self.scan_num_ypoints )
            self.ypoints = list(ypoints)
            
            if self.scan_3D:
                zpoints = pylab.linspace( centerZ+self.scan_zrange/2*self.piezoZ['direction'], 
                                          centerZ-self.scan_zrange/2*self.piezoZ['direction'], 
                                          self.scan_num_zpoints )
                self.zpoints = list(zpoints)
            else:
                self.zpoints = [centerZ]
            
            self.clear_scans()
            self.lastpoint = dict(x=0,y=0)
            self.data = dict( scans=self.scans, 
                        xpoints=self.xpoints,
                        ypoints=self.ypoints,
                        lastpoint=self.lastpoint
                              )

            if self.scan_start == 0:
                # 'top left corner' (lowest X and lowest Y)
                X, Y = pylab.meshgrid( xpoints, ypoints )
                
                # this flips every other row so that we reverse direction at end.
                for i in range( 1, X.shape[0], 2 ):
                    c = X[i,:].copy()
                    X[i,:] = c[::-1]
                    
                xp = X.flatten()
                yp = Y.flatten()
                
            # TODO:
            elif self.scan_start == 1:
                # 'top right corner'
                pass
            elif self.scan_start == 2:
                # 'bottom left corner'
                pass
            else:
                # 'bottom right corner'
                pass
            
            self.raster_points = []
            for i in range( len(xp) ):
                self.raster_points.append(dict( x=xp[i],
                                                ix=self.xpoints.index(xp[i]),
                                                y=yp[i],
                                                iy=self.ypoints.index(yp[i]),
                                                scan_num=i
                                                ))
        
        
        def check_winspec_stopped( self ):
            expt_is_running, status = self.WinspecExpt.GetParam( expt_running )
            if expt_is_running:
                print 'Winspec already running!!!'
                return False
            else:
                return True


        def clear_scans( self ):
            self.scans = []
            for i in range(len(self.xpoints)):
                self.scans.append( [None]*len(self.ypoints) )
            
        def get_wavelength( self ):
            calibration = self.WinspecDoc.GetCalibration()
            if calibration.Order != 2:
                raise ValueError('Cannot handle current winspec wavelength calibration...')
            p = pylab.array([ calibration.PolyCoeffs(2),
                              calibration.PolyCoeffs(1),
                              calibration.PolyCoeffs(0) ])
            self.wavelen = pylab.polyval( p, xrange( 1, 1+len(self.spectrum) ) )
            self.data['wavelen'] = self.wavelen
            


        def initialize_detector( self ):
            if self.use_winspec:
                w32c.pythoncom.CoInitialize()
                self.WinspecDoc = w32c.Dispatch("WinX32.DocFile")
                self.WinspecExpt = w32c.Dispatch("WinX32.ExpSetup")

                if not self.check_winspec_stopped():
                    wx.PostEvent(self._parent, ResultEvent(None))
                    w32c.pythoncom.CoUninitialize()
                    return False
            else:
                self.device0 = ctypes.c_int(0)
                self.channel0 = ctypes.c_int(0)
                self.channel1 = ctypes.c_int(1)

                self.ZeroCross0 = ctypes.c_long(9)  # in mV, for laser reference (not APD)
                self.Discr0 = ctypes.c_long(15)     # in mV, for laser reference (not APD)
                self.ZeroCross1 = ctypes.c_long(10) # in mV
                self.Discr1 = ctypes.c_long(50)     # in mV

                self.sync_divider = 8
                self.SyncDivider = ctypes.c_long(self.sync_divider) # 1 is "None"

                serial = ctypes.c_char_p('xxxxxx')
                if phlib.PH_OpenDevice( self.device0, ctypes.byref(serial) ) < 0: self.shutdown_APDs( self.device0, normal_operation=False )
                if phlib.PH_Initialize( self.device0, ctypes.c_int(2) ) < 0: self.shutdown_APDs( self.device0, normal_operation=False )

                if phlib.PH_SetSyncDiv( self.device0, self.SyncDivider ) < 0: self.shutdown_APDs( self.device0, normal_operation=False )
                if phlib.PH_SetCFDLevel( self.device0, ctypes.c_long(0), self.Discr0 ) < 0: self.shutdown_APDs( self.device0, normal_operation=False )
                if phlib.PH_SetCFDZeroCross( self.device0, ctypes.c_long(0), self.ZeroCross0 ) < 0: self.shutdown_APDs( self.device0, normal_operation=False )
                if phlib.PH_SetCFDLevel( self.device0, ctypes.c_long(1), self.Discr1 ) < 0: self.shutdown_APDs( self.device0, normal_operation=False )
                if phlib.PH_SetCFDZeroCross( self.device0, ctypes.c_long(1), self.ZeroCross1 ) < 0: self.shutdown_APDs( self.device0, normal_operation=False )

            
        def move_focus( self, z ):
            self.piezoZ['control'].SetPositionSmooth( position=z, step=0.25 )
            Publisher().sendMessage("piezos-moved", 'raster')
        

        def move_to_position( self, position ):
            self.piezoX['control'].SetPositionSmooth( position=position['x'], step=0.25 )
            self.piezoY['control'].SetPositionSmooth( position=position['y'], step=0.25 )
            
            Publisher().sendMessage("piezos-moved", 'raster')
        
        

        def on_abort( self ):
            self.move_to_position( self.origin )
            self.move_focus( self.origin['z'] )
            wx.PostEvent(self._parent, ResultEvent(None))
            if self.use_winspec:
                w32c.pythoncom.CoUninitialize()
            else:
                self.shutdown_APDs( self.device0 )
            return False                


        def on_done( self ):
            self.move_to_position( self.origin )
            wx.PostEvent(self._parent, ResultEvent(True))
            if self.use_winspec:
                w32c.pythoncom.CoUninitialize()
            else:
                self.shutdown_APDs( self.device0 )


        def read_APDs( self ):
            num_acq = 100 # number of queries to average (each ~0.5ms)
            cps_ch1 = 0.0
            for i in range(num_acq):
                cps_ch1 += phlib.PH_GetCountRate( self.device0, self.channel1 )

            self.APD_cps = cps_ch1 / num_acq


        def reinitialize_scans( self ):
            for p in self.raster_points:
                self.scans[p['ix']][p['iy']] = None
            
        def run( self ):
            self.initialize_detector()
                
            steps_completed = 0
            
            self.calculate_raster_points()
            self.data['wait_for_save'] = [False]
            
            for z in self.zpoints:
                self.data['z'] = z
                self.move_focus(z)
                self.move_to_position( self.raster_points[0] )
                time.sleep( 2.0 ) # give objective time to settle
                """ This is a vile hack!!! I'm faking thread communication by setting the value
                    of a list within self.data. A better approach would be to do explicit event
                    handling. But this is so easy...
                """
                while self.data['wait_for_save'][0]: pass
                self.reinitialize_scans()

                for point in self.raster_points:
                    self.move_to_position( point )
                    if self._want_abort: return self.on_abort()
                    time.sleep( 0.01 ) # give objective time to move
                    self.acquire_signal( point, steps_completed )
                    steps_completed += 1
                    if self._want_abort: return self.on_abort()
                    wx.PostEvent(self._parent, UpdateEvent(self.data))
                
                if self.scan_3D: wx.PostEvent(self._parent, UpdateEvent(self.data, "Z"))
                
            self.on_done()
            return True
            

        def shutdown_APDs( self, device, normal_operation=True ):
            phlib.PH_CloseDevice( device )
            if not normal_operation:
                #raise ValueError('APD access failed.')
                print 'Error in APD communication.'
                self._want_abort = True
                return False
                


if __name__ == "__main__":
    app = MainApp()
    app.MainLoop()

